#!/usr/bin/env node
'use strict';

const TypeDoc = require('typedoc');
const highlightJs = require('highlight.js');
const path = require('path');
const fs = require('fs-extra');
const MarkdownIt = require('markdown-it');
const markdown = new MarkdownIt({
    html: true,
    typographer: true,
    highlight: function (str, lang) {
        if ((lang ?? 'typescript') && highlightJs.getLanguage(lang)) {
            try {
                return highlightJs.highlight(lang, str).value;
            }
            catch (err) {
                console.log(err);
            }
        }
        return '';
    },
});
function span(value, className) {
    if (!className)
        return '<span>' + value + '</span>';
    return '<span class="' + className + '">' + value + '</span>';
}
function div(content, className) {
    if (className) {
        return '\n<div class="' + className + '">' + content + '</div>\n';
    }
    return '\n<div>' + content + '</div>\n';
}
function punct(value) {
    return '<span class="punctuation">' + value + '</span>';
}
function keyword(k) {
    return '<span class="keyword">' + k + '</span>';
}
function section(content, options) {
    let result = '<section';
    if (options?.keywords) {
        result += ' data-keywords="' + options.keywords.toLowerCase() + '"';
    }
    if (options?.permalink?.anchor) {
        result += ' id="' + encodeURIComponent(options.permalink.anchor) + '"';
    }
    if (options?.className) {
        result += ' class="' + options.className + '"';
    }
    result += '>' + content;
    return result + '\n</section>\n';
}
function list(items, className) {
    if (!items || items.length === 0)
        return '';
    let result = '';
    if (Array.isArray(items[0])) {
        const definitions = items;
        if (className) {
            result += '\n<dl class="' + className + '">\n';
        }
        else {
            result += '\n<dl>\n';
        }
        result += definitions
            .map((def) => '\n<dt>' + def[0] + '</dt>\n<dd>' + def[1] + '</dd>\n')
            .join('');
        result += '\n</dl>\n';
    }
    else {
        if (className) {
            result += '\n<ul class="' + className + '">\n';
        }
        else {
            result += '\n<ul>\n';
        }
        result += items.map((item) => '\n<li>' + item + '</li>\n').join('');
        result += '\n</ul>\n';
    }
    return result;
}
function highlightingMark(content) {
    return span(content +
        '<svg class="highlighting-mark"><use xlink:href="#highlighting-mark-' +
        (Math.floor(3 * Math.random()) + 1) +
        '"></use></svg>', 'highlighting-mark-container');
}
function heading(level, subhead, head, permalink, options) {
    const tag = 'h' + Number(level).toString();
    let body = subhead ? span(subhead, 'subhead') : '';
    if (permalink?.anchor) {
        body += highlightingMark(span(head, options?.deprecated ? 'head deprecated' : 'head'));
        body = span(body, 'stack');
        body += renderPermalinkAnchor(permalink);
    }
    else {
        body += span(head, options?.deprecated ? 'head deprecated' : 'head');
        body = span(body, 'stack');
    }
    return ('<' +
        tag +
        (options?.className ? ' class="' + options.className + '"' : '') +
        '>' +
        body +
        '</' +
        tag +
        '>');
}
function getReflectionByID(id, root = gNodes) {
    if (root.type !== 'reference' && root.id === id)
        return root;
    let result;
    if (root.children?.some((x) => {
        result = getReflectionByID(id, x);
        return result !== null;
    }) ??
        false) {
        return result;
    }
    return null;
}
function getReflectionsByName(name, root) {
    if (!root)
        root = gNodes;
    let result = [];
    if (getName(root) === name)
        result.push(root);
    if (root.children) {
        root.children.forEach((x) => {
            result = [...result, ...getReflectionsByName(name, x)];
        });
    }
    return result;
}
function getReflectionByName(name, root, kind) {
    let candidates = [];
    candidates = getReflectionsByName(name, root);
    if (candidates.length > 0) {
        candidates.sort((a, b) => b.kind - a.kind);
        if (typeof kind === 'number') {
            candidates = candidates.filter((x) => (x.kind & kind) !== 0);
        }
        else if (kind === 'static') {
            candidates = candidates.filter((x) => x.kind === 2048 && hasFlag(x, 'isStatic'));
        }
        else if (typeof kind === 'string') {
            const numKind = NUMERIC_KIND[kind];
            candidates = candidates.filter((x) => (x.kind & numKind) !== 0);
        }
        if (candidates.length > 0) {
            return candidates[0];
        }
    }
    return null;
}
const NUMERIC_KIND = {
    namespace: 2,
    enum: 4,
    variable: 32,
    function: 64,
    class: 128,
    interface: 256,
    instance: 1024 | 2048 | 262144,
    static: 1024 | 2048,
    type: 4194304,
};
function getNameSelector(segment) {
    const m = segment.match(/^\(([^\:]+)(\:([^\)]+))?\)$/);
    if (m) {
        return [m[1], m[3]];
    }
    return [segment, undefined];
}
function getReflectionByLink(link, root) {
    const segments = link.split('.');
    if (segments.length === 1) {
        const [name, kind] = getNameSelector(segments[0]);
        return (getReflectionByName(name, root, kind) ||
            getReflectionByName(name, getParent(root), kind) ||
            getReflectionByName(name, null, kind));
    }
    const lastSegment = segments.pop();
    let node = null;
    for (const segment of segments) {
        const [name, kind] = getNameSelector(segment);
        node = getReflectionByName(name, node, kind);
    }
    return getReflectionByLink(lastSegment, node);
}
function getAncestors(node, root = gNodes) {
    if (!node)
        return null;
    if (node.id === root.id)
        return [root];
    if (root.children) {
        for (const child of root.children) {
            const ancestors = getAncestors(node, child);
            if (ancestors) {
                return [...ancestors, root];
            }
        }
    }
    return null;
}
function getParent(node) {
    return getAncestors(node)?.[1] ?? null;
}
function getChildrenByID(node, children) {
    return children.map((x) => node.children.filter((child) => child.id === x)[0]);
}
function getName(node) {
    if (node.kind === 1) {
        return getModuleName(node);
    }
    return node.name;
}
function everyStringLiteral(nodes) {
    return nodes.every((x) => x.type === 'stringLiteral');
}
function sortOtherCategoryAtEnd(categories) {
    return categories.sort((a, b) => {
        if (a.title === b.title)
            return 0;
        if (a.title === 'Other')
            return 1;
        if (b.title === 'Other')
            return -1;
        return a.title < b.title ? -1 : 1;
    });
}
const KIND_ORDER = {
    512: 1,
    64: 2,
    2048: 3,
    262144: 4,
    1024: 5,
    32: 6,
    256: 7,
    128: 8,
    2: 9,
    4194304: 10,
    4: 11,
};
function sortGroups(groups) {
    return groups.sort((a, b) => {
        console.assert(KIND_ORDER[b.kind] && KIND_ORDER[a.kind]);
        return KIND_ORDER[a.kind] === KIND_ORDER[b.kind]
            ? 0
            : KIND_ORDER[a.kind] < KIND_ORDER[b.kind]
                ? -1
                : +1;
    });
}
function getCategories(node, kind) {
    let result = [];
    const children = node.groups?.filter((x) => (x.kind & kind) !== 0);
    if (!children || children.length !== 1) {
        if (node.categories) {
            return sortOtherCategoryAtEnd(node.categories);
        }
        return [
            {
                title: '',
                children: node.children.filter((x) => (x.kind & kind) !== 0),
            },
        ];
    }
    if (children[0].categories) {
        result = children[0].categories.map((category) => {
            return {
                title: category.title,
                children: getChildrenByID(node, category.children),
            };
        });
        result = sortOtherCategoryAtEnd(result);
    }
    else {
        console.assert(typeof children[0].children[0] === 'number');
        result = [
            {
                title: '',
                children: getChildrenByID(node, children[0].children),
            },
        ];
    }
    return result;
}
function makePermalink(node) {
    node = getReflectionByID(node.id);
    if (!node || node.kind === 0) {
        return null;
    }
    if (node.sources?.[0]?.fileName.endsWith('/lib.dom.d.ts')) {
        return {
            document: 'https://developer.mozilla.org/en-US/docs/Web/API/' + node.name,
            anchor: '',
            title: node.name,
        };
    }
    const parent = getParent(node);
    if (!parent) {
        return { anchor: '', title: node.name ?? '' };
    }
    let result;
    if (node.kind === 512) {
        const grandparentPermalink = makePermalink(getParent(parent));
        if (grandparentPermalink) {
            result = {
                anchor: (grandparentPermalink.anchor
                    ? grandparentPermalink.anchor + '.'
                    : '') +
                    parent.name +
                    ':constructor',
                title: 'new ' + parent.name + '()',
            };
        }
        else {
            result = {
                anchor: parent.name + ':constructor',
                title: 'new ' + parent.name + '()',
            };
        }
    }
    else {
        const qualifiedSymbol = getQualifiedSymbol(parent, node);
        const parentPermalink = makePermalink(parent);
        const nodeName = getName(node);
        result = parentPermalink
            ? {
                anchor: (parentPermalink.anchor
                    ? parentPermalink.anchor + '.'
                    : '') + qualifiedSymbol,
                title: parentPermalink.title + '.' + nodeName,
            }
            : {
                anchor: qualifiedSymbol,
                title: nodeName,
            };
    }
    if (shouldIgnore(node)) {
        result.anchor = '';
    }
    return result;
}
function renderPermalink(permalink, title) {
    if (!permalink)
        return '';
    title = title ?? permalink.title;
    if (permalink.document && permalink.anchor) {
        return `<a href="${permalink.document}#${encodeURIComponent(permalink.anchor)}">${title}</a>`;
    }
    else if (permalink.document) {
        return `<a href="${permalink.document}">${title}</a>`;
    }
    else if (permalink.anchor) {
        return `<a href="#${encodeURIComponent(permalink.anchor)}">${title}</a>`;
    }
    return title;
}
function renderPermalinkAnchor(permalink) {
    console.assert(!permalink.document);
    return ('<a class="permalink" href="#' +
        encodeURIComponent(permalink.anchor) +
        '" title="Permalink"><span class="sr-only"> Permalink </span>' +
        '<svg><use xlink:href="#link"></use></svg>' +
        '</a>');
}
function renderIndex(node, title, categories, options) {
    if (!categories || categories.length === 0)
        return '';
    let result = '';
    if (title) {
        result = heading(3, getQualifiedName(node), title);
    }
    if (categories.length === 1 &&
        filterInherited(filterPrivate(categories[0].children)).length <= 1) {
        return result;
    }
    options = options || { symbolSuffix: '' };
    return (result +
        categories
            .map((category) => {
            let r = '';
            if (category.title) {
                r += `\n\n<h4>${category.title}</h4>\n`;
            }
            let items = category.children.map((x) => typeof x === 'number' ? getReflectionByID(x) : x);
            items = items.filter((x) => {
                if (!x.inheritedFrom &&
                    x.name?.[0] !== '#' &&
                    !shouldIgnore(x)) {
                    if (x.signatures) {
                        return (x.signatures.filter((x) => !shouldIgnore(x))
                            .length > 0);
                    }
                    return true;
                }
                return false;
            });
            r +=
                '\n<div class="index">' +
                    list(items.map((x) => renderPermalink(makePermalink(x), getName(x) + options.symbolSuffix))) +
                    '\n</div>\n';
            return r;
        })
            .join('\n'));
}
function hasFlag(node, flag) {
    return node?.flags?.[flag];
}
function getTag(node, tag) {
    if (node?.comment?.tags) {
        const result = node.comment.tags.filter((x) => x.tag === tag);
        console.assert(result.length <= 1);
        if (result.length === 1) {
            return result[0].text || '';
        }
    }
    return '';
}
function hasTag(node, tag) {
    return (node?.comment?.tags &&
        node.comment.tags.filter((x) => x.tag === tag).length > 0);
}
function getKeywords(node) {
    if (node.signatures && !node.comment) {
        return getKeywords(node.signatures[0]);
    }
    let keywords = getTag(node, 'keywords');
    if (!keywords && hasTag(node, 'keyword')) {
        console.warn('The tag for keywords is "@keywords", not "@keyword" ', getQualifiedName(node));
        keywords = getTag(node, 'keyword');
    }
    let result = (keywords ?? '').split(',');
    result.push({
        2: 'namespace',
        4: 'enum',
        32: 'variable',
        16: '',
        64: 'function',
        128: 'class',
        256: 'interface',
        1024: '',
        2048: '',
        4096: 'function',
        262144: 'instance',
        524288: 'instance',
        4194304: 'type',
    }[node.kind] ?? '');
    result.push(getName(node));
    if (hasTag(node, 'category')) {
        const category = getTag(node, 'category')
            .split(' ')
            .map((x) => x.toLowerCase().trim());
        result = [...result, ...category];
    }
    result = [].concat(...result.map((word) => {
        if (gOptions.keywordSynonyms?.hasOwnProperty(word) ?? false) {
            return [word, ...gOptions.keywordSynonyms[word]];
        }
        return [word];
    }));
    result = result
        .filter((x) => !!x)
        .map((x) => x.trim().toLowerCase());
    return [...new Set(result)];
}
function renderFlags(node, style = 'block') {
    if (!node)
        return '';
    let result = '';
    if (node.flags) {
        if (node.flags.isAbstract)
            result += span('abstract', 'modifier-tag');
        if (node.flags.isPrivate)
            result += span('private', 'modifier-tag');
        if (node.flags.isProtected)
            result += span('protected', 'modifier-tag');
        if (node.flags.isPublic)
            result += span('public', 'modifier-tag');
        if (node.flags.isExternal)
            result += span('external', 'modifier-tag');
        if (node.flags.isStatic)
            result += span('static', 'modifier-tag');
    }
    const TAGS = {
        eventproperty: '',
        override: '',
        readonly: '',
        sealed: '',
        virtual: '',
        deprecated: 'red modifier-tag',
        beta: 'orange modifier-tag',
        alpha: 'orange modifier-tag',
        experimental: 'orange modifier-tag',
    };
    const TAG_NAME = {
        eventproperty: 'event',
        readonly: 'read only',
    };
    result += Object.keys(TAGS)
        .map((x) => hasTag(node, x)
        ? span(TAG_NAME[x] || x, TAGS[x] || 'modifier-tag')
        : '')
        .join('');
    return result
        ? style === 'block'
            ? div(result, 'flags')
            : span(result, 'flags')
        : '';
}
function renderTag(node, tag, text) {
    if (!tag || !text)
        return '';
    let result = '';
    text = trimNewline(text.trim()) || '';
    switch (tag) {
        case 'method':
            result +=
                '<strong>Method:</strong> ' +
                    markdown.render(renderLinkTags(node, text));
            break;
        case 'module':
            result +=
                '<strong>Module:</strong> ' +
                    markdown.render(renderLinkTags(node, text));
            break;
        case 'function':
            result +=
                '<strong>Function:</strong> ' +
                    markdown.render(renderLinkTags(node, text));
            break;
        case 'example':
            result +=
                '\n<pre><code>' +
                    highlightJs.highlight('typescript', text).value +
                    '</code></pre>\n';
            break;
        case 'typedef':
        case 'type':
        case 'property':
        case 'param':
        case 'returns':
            break;
        case 'privateremarks':
            break;
        case 'packageDocumentation':
            break;
        case 'category':
            break;
        case 'global':
            break;
        case 'keywords':
            break;
        case 'command':
            break;
        case 'keyword':
            console.warn('Unexpected tag "@keyword" in ' +
                node.name +
                '. Did you mean "@keywords"?');
        default:
            if (text) {
                const noticeStyle = {
                    eventproperty: 'info',
                    override: 'info',
                    public: 'info',
                    readonly: 'info',
                    sealed: 'info',
                    virtual: 'info',
                    alpha: 'warning',
                    beta: 'warning',
                    experimental: 'warning',
                    deprecated: 'danger',
                    internal: 'danger',
                }[tag] || 'info';
                const tagLabel = { eventproperty: 'event' }[tag] || tag;
                result += section('<h4>' +
                    tagLabel +
                    '</h4>\n\n' +
                    markdown.render(renderLinkTags(node, text)), { className: 'notice--' + noticeStyle });
            }
            else if (!/alpha|beta|deprecated|eventproperty|experimental|internal|override|public|readonly|sealed|virtual/i.test(tag)) {
                result += '<strong>' + tag + '</strong>';
            }
            else ;
    }
    return result;
}
function escapeYAMLString(str) {
    return str.replace(/([^\\])'/g, "$1\\'");
}
function trimQuotes(str) {
    return str.replace(/(^")|("$)/g, '');
}
function trimNewline(str) {
    return str.replace(/(\n+)$/g, '');
}
function isVoid(node) {
    return (node.type === 'void' ||
        (node.type === 'intrinsic' && node.name === 'void'));
}
function getQualifiedSymbol(parent, node) {
    if (node.kind === 0) {
        return '';
    }
    if (node.kind === 1) {
        console.assert(parent.kind === 0);
        if (parent.children.length === 1) {
            return '';
        }
        return '("' + getModuleName(node) + '":module)';
    }
    if (node.kind === 2) {
        if (/^"(.*)"$/.test(node.name)) {
            return '("' + trimQuotes(node.name) + '":module)';
        }
        return '(' + node.name + '":namespace)';
    }
    if (node.type === 'reference') {
        node = getReflectionByID(node.id);
    }
    const symbol = node.name;
    let selector = {
        2: 'namespace',
        4: 'enum',
        32: 'variable',
        16: '',
        64: 'function',
        128: 'class',
        256: 'interface',
        1024: '',
        2048: '',
        4096: 'function',
        262144: 'instance',
        524288: 'instance',
        4194304: 'type',
        16777216: 'reference',
    }[node.kind];
    console.assert(typeof selector !== 'undefined');
    if (node.kind === 512) {
        return ':constructor';
    }
    if (parent && parent.kind === 128) {
        if (node.kind === 1024 || node.kind === 2048) {
            if (node.flags?.isStatic) {
                selector = 'static';
            }
            else {
                selector = 'instance';
            }
        }
    }
    else if (parent?.kind === 256) {
        selector = '';
    }
    const label = getTag(node, 'label');
    if (label) {
        selector = label;
    }
    return selector ? `(${symbol}:${selector})` : symbol;
}
function getQualifiedName(node) {
    if (!node || node.kind === 0)
        return '';
    if (node.kind === 128 && hasFlag(node, 'isAbstract')) {
        return (keyword('abstract class ') +
            '<strong>' +
            getName(node) +
            '</strong>');
    }
    if (node.kind === 1) {
        return keyword('module ') + '<strong>"' + getName(node) + '"</strong>';
    }
    return (keyword({
        256: 'interface ',
        128: 'class ',
        4: 'enum ',
        2: 'namespace ',
        1: 'module ',
    }[node.kind] ?? '') +
        '<strong>' +
        getName(node) +
        '</strong>');
}
function resolveLink(node, link) {
    if (/^http[s]?:\/\//.test(link)) {
        return link;
    }
    if (!getReflectionByLink(link, node)) {
        console.warn('Unresolved link in "' + node.name + '": ', link);
    }
    let result = '';
    const imports = link.split('#');
    if (imports.length > 1) {
        result = imports[0];
        link = imports.slice(1).join('');
    }
    const linkSegments = link.split('.');
    let root = gNodes;
    linkSegments.forEach((linkSegment) => {
        root = getReflectionByLink(linkSegment, root);
    });
    return root
        ? result + '#' + encodeURIComponent(makePermalink(root).anchor)
        : result + '#' + linkSegments.join('.');
}
function getTutorial(path) {
    if (!gOptions.tutorialPath)
        return path;
    if (!gOptions.tutorialPath.endsWith('/')) {
        return gOptions.tutorialPath + '/' + path;
    }
    return gOptions.tutorialPath + path;
}
function filterPrivate(list) {
    return list.filter((x) => x.name?.[0] !== '#');
}
function filterInherited(list) {
    return list.filter((x) => !x.inheritedFrom);
}
function renderLinkTags(node, str) {
    str = str.replace(/{@tutorial\s+(\S+?)[ \|]+(.+?)}/g, (_match, p1, p2) => `<a href="${getTutorial(p1)}">${p2}</a>`);
    str = str.replace(/{@tutorial\s+(\S+?)}/g, (_match, p1) => `<a href="${getTutorial(p1)}">${p1}</a>`);
    str = str.replace(/{@linkcode\s+(\S+?)\s*\|\s*(.+?)}/g, (_match, p1, p2) => `<a href="${resolveLink(node, p1)}"><code>${p2}</code></a>`);
    str = str.replace(/{@linkcode\s+(\S+?)}/g, (_match, p1) => `<a href="${resolveLink(node, p1)}"><code>${p1}</code></a>`);
    str = str.replace(/\[\[\`(\S+?)\`\s*\|\s*(.+?)\]\]/g, (_match, p1) => `<a href="${resolveLink(node, p1)}"><code>${p1}</code></a>`);
    str = str.replace(/\[\[\`(\S+?)\`\]\]/g, (_match, p1) => `<a href="${resolveLink(node, p1)}"><code>${p1}</code></a>`);
    str = str.replace(/{@(?:link|linkplain)\s+(\S+?)\s*\|\s*(.+?)}/g, (_match, p1, p2) => `<a href="${resolveLink(node, p1)}">${p2}</a>`);
    str = str.replace(/{@(?:link|linkplain)\s+(\S+?)}/g, (_match, p1) => `<a href="${resolveLink(node, p1)}">${p1}</a>`);
    str = str.replace(/\[\[(\S+?)\s*\|\s*(.+?)\]\]/g, (_match, p1, p2) => `<a href="${resolveLink(node, p1)}">${p2}</a>`);
    str = str.replace(/\[\[(\S+?)\]\]/g, (_match, p1) => `<a href="${resolveLink(node, p1)}">${p1}</a>`);
    str = str.replace(/({@(?:inheritDoc)\s+(\S+?)})/gi, (_match, p1, p2) => {
        if (!p1.startsWith('{@inheritDoc')) {
            console.warn('Check capitalization of @inheritDoc', p1);
        }
        const source = getReflectionByLink(p2, node);
        if (!source) {
            console.warn('Unresolved link in "' + node.name + '": ', p1);
            return p1;
        }
        return render(source, 'block-inherit');
    });
    return str;
}
function renderNotices(node, str) {
    const lines = str.split('\n');
    const blocks = [];
    let inShortBlock = false;
    let inLongBlock = false;
    let currentBlock = [];
    let currentType = '';
    lines.forEach((line) => {
        if (inShortBlock) {
            const m = line.match(/^\s*$/i);
            if (m) {
                if (currentBlock.length > 0) {
                    blocks.push({
                        type: currentType,
                        content: currentBlock.join('\n'),
                    });
                }
                inShortBlock = false;
                currentType = '';
                currentBlock = [];
            }
            else {
                currentBlock.push(line);
            }
        }
        else if (inLongBlock) {
            if (/^[ ]{0,3}(\*\*\*|---)/.test(line)) {
                if (currentBlock.length > 0) {
                    blocks.push({
                        type: currentType,
                        content: currentBlock.join('\n'),
                    });
                }
                inLongBlock = false;
                currentType = '';
                currentBlock = [];
            }
            else {
                currentBlock.push(line);
            }
        }
        else {
            let m = line.match(/\n*\*\*\(([^]+)\):?\s*\*\*\s*:?\s*([^]+)/i);
            if (m) {
                if (currentBlock.length > 0) {
                    blocks.push({
                        type: currentType,
                        content: currentBlock.join('\n'),
                    });
                }
                inShortBlock = true;
                currentType = m[1];
                currentBlock = [m[2]];
            }
            else {
                m = line.match(/\n*\*\*\(([^]+)\):?\s*\*\*\s*:?\s*$/i);
                if (m) {
                    if (currentBlock.length > 0) {
                        blocks.push({
                            type: currentType,
                            content: currentBlock.join('\n'),
                        });
                    }
                    inLongBlock = true;
                    currentType = m[1];
                    currentBlock = [];
                }
                else {
                    currentBlock.push(line);
                }
            }
        }
    });
    if (currentBlock.length > 0) {
        blocks.push({ type: currentType, content: currentBlock.join('\n') });
    }
    return blocks
        .map((block) => {
        if (block.type) {
            const noticeType = {
                danger: 'danger',
                warning: 'warning',
                caution: 'warning',
            }[block.type.toLowerCase()] || 'info';
            return div(`<h4>${block.type}</h4>\n` +
                markdown.render(renderLinkTags(node, block.content)), 'notice--' + noticeType);
        }
        return markdown.render(renderLinkTags(node, block.content));
    })
        .join('\n');
}
function renderComment(node, style) {
    if (!node)
        return '';
    if (node.signatures && !node.comment) {
        return renderComment(node.signatures[0], style);
    }
    if (!node.comment)
        return '';
    let result = '';
    const newLine = '\n';
    if (node.comment.shortText) {
        result += renderNotices(node, node.comment.shortText) + newLine;
    }
    if (node.comment.text) {
        result += renderNotices(node, node.comment.text) + newLine;
    }
    const remarks = getTag(node, 'remarks');
    if (remarks) {
        result += renderNotices(node, remarks) + newLine;
    }
    if (style !== 'block-inherit') {
        if (node.comment.tags && node.comment.tags.length > 0) {
            result +=
                newLine +
                    node.comment.tags
                        .map((x) => renderTag(node, x.tag, x.text))
                        .filter((x) => !!x)
                        .join(newLine + newLine) +
                    newLine;
        }
    }
    return result;
}
function getModuleName(node) {
    if (!node)
        return '';
    if (node.kind === 1) {
        const result = trimQuotes(node.name).replace(/\.d$/, '');
        return result.match(/\/([a-z0-9_-]*[\/]?)$/)?.[1] ?? result;
    }
    return getModuleName(getParent(node));
}
function shouldIgnore(node) {
    return (hasTag(node, 'hidden') ||
        hasTag(node, 'ignore') ||
        hasTag(node, 'internal') ||
        node.name[0] === '#');
}
function renderCard(node, displayName, content) {
    const parent = getParent(node);
    if (!displayName) {
        displayName = `<strong>${getName(node)}</strong>`;
        if (node.kind === 4 ||
            node.kind === 32 ||
            node.kind === 64 ||
            node.kind === 128 ||
            node.kind === 256 ||
            node.kind === 1024 ||
            node.kind === 2048) {
            if (parent &&
                ((parent.kind === 2 && !/^"(.*)"$/.test(parent.name)) ||
                    parent.kind === 128 ||
                    parent.kind === 256)) {
                displayName = getName(parent) + punct('.') + displayName;
            }
        }
        if (node.kind === 64) {
            displayName += punct('()');
        }
    }
    const permalink = makePermalink(node);
    console.assert(!permalink.document);
    const header = heading(3, getQualifiedName(parent), displayName, permalink, { deprecated: hasTag(node, 'deprecated') });
    return section(header + content, {
        permalink,
        className: 'card',
        keywords: getKeywords(node).join(', '),
    });
}
function renderMethodCard(node) {
    if (shouldIgnore(node))
        return '';
    const result = renderCommandCard(node);
    if (result)
        return result;
    const parent = getParent(node);
    let displayName = '';
    let shortName = '';
    if (node.kind === 512) {
        displayName = `${keyword('new ')}<strong>${parent.name}</strong>`;
        shortName = displayName;
    }
    else {
        shortName = `<strong>${node.name}</strong>`;
        displayName = shortName;
    }
    const signatures = node.signatures.filter((x) => !shouldIgnore(x));
    if (signatures.length === 0)
        return '';
    return renderCard(node, displayName, renderComment(node, 'block') +
        div(signatures
            .map((signature) => {
            let result = renderFlags(signature);
            result += div(shortName + render(signature, 'inline'), 'code');
            result += render(signature, 'block');
            return div(result);
        })
            .join('\n<hr>\n')));
}
function renderAccessorCard(node) {
    if (shouldIgnore(node))
        return '';
    let displayName = '';
    if (node.getSignature && node.setSignature) {
        displayName = keyword('get/set ') + `<strong>${node.name}</strong>`;
    }
    else if (node.getSignature) {
        displayName = keyword('get ') + `<strong>${node.name}</strong>`;
    }
    else {
        displayName = keyword('set ') + `<strong>${node.name}</strong>`;
    }
    const signature = node.getSignature
        ? node.getSignature[0]
        : node.setSignature[0];
    let body = node.name + punct(': ') + render(signature.type, 'inline');
    if (node.getSignature && !node.setSignature) {
        body += '&nbsp;&nbsp;' + span('read only', 'modifier-tag');
    }
    else if (!node.getSignature && node.setSignature) {
        body += '&nbsp;&nbsp;' + span('write only', 'modifier-tag');
    }
    return renderCard(node, displayName, div(body) + renderComment(node, 'block'));
}
function renderClassSection(node) {
    if (shouldIgnore(node) || !node.children)
        return '';
    if (node.groups.length === 1 &&
        (node.groups[0].kind & (1024 | 2048)) !== 0 &&
        !hasTag(node, 'command')) {
        return render(node, 'card');
    }
    const permalink = makePermalink(node);
    const parent = getParent(node);
    const result = heading(2, getQualifiedName(parent), getQualifiedName(node), permalink, { deprecated: hasTag(node, 'deprecated') }) + renderFlags(node);
    let body = '';
    if (node.extendedTypes) {
        body +=
            '<p>' +
                span('Extends', 'class-label') +
                node.extendedTypes
                    .map((x) => render(x))
                    .filter((x) => !!x)
                    .join(', ') +
                '</p>';
    }
    if (node.implementedTypes && node.implementedTypes.length > 0) {
        if (node.implementedTypes.length > 0) {
            body +=
                '<p>' +
                    span('Implements', 'class-label') +
                    node.implementedTypes
                        .map((x) => render(x))
                        .filter((x) => !!x)
                        .join(', ') +
                    '</p>';
        }
    }
    if (node.extendedBy) {
        body +=
            '<p>' +
                span('Extended by', 'class-label') +
                node.extendedBy
                    .map((x) => render(x))
                    .filter((x) => !!x)
                    .join(', ') +
                '</p>';
    }
    if (node.implementedBy) {
        const implementedBy = node.implementedBy.filter((x) => x.id !== node.id);
        if (implementedBy.length > 0) {
            body +=
                '<p>' +
                    span('Implemented by', 'class-label') +
                    implementedBy
                        .map((x) => render(x))
                        .filter((x) => !!x)
                        .join(', ') +
                    '</p>';
        }
    }
    return section(result + div(body) + renderGroups(node), { permalink });
}
function renderClassCard(node) {
    if (shouldIgnore(node) || !node.children)
        return '';
    let comment = renderComment(node, 'block');
    if (comment)
        comment += '\n<hr>\n';
    let body = '';
    if (node.children) {
        body =
            '<dl><dt id="' +
                filterPrivate(node.children)
                    .map((x) => {
                    const permalink = makePermalink(x);
                    let r = encodeURIComponent(permalink.anchor) + '">';
                    if (x.kind === 2048) {
                        r +=
                            x.signatures
                                .map((signature) => {
                                let sigResult = renderFlags(x, 'inline') +
                                    '<strong>' +
                                    x.name +
                                    '</strong>';
                                if (hasFlag(x, 'isOptional')) {
                                    sigResult += span('?', 'modifier');
                                }
                                sigResult +=
                                    renderPermalinkAnchor(permalink) +
                                        render(signature) +
                                        '</dt><dd>' +
                                        renderComment(signature, 'block');
                                return sigResult;
                            })
                                .join('</dd><dt>') + '</dd>';
                    }
                    else if (x.kind === 1024) {
                        r += '<strong>' + x.name + '</strong>';
                        if (hasFlag(x, 'isOptional')) {
                            r += span('?', 'modifier');
                        }
                        r +=
                            punct(': ') +
                                render(x.type) +
                                renderPermalinkAnchor(permalink) +
                                '</dt><dd>' +
                                renderComment(x, 'block');
                    }
                    else {
                        console.error('Unexpected item in a "short" class/interface');
                    }
                    return r;
                })
                    .join('\n</dd><dt id="');
        body += '\n</dd></dl>\n';
    }
    return renderCard(node, getQualifiedName(node), comment + body);
}
function renderCommandCard(node) {
    const parent = getParent(node);
    const commandTag = (getTag(node, 'command') || getTag(parent, 'command')).trim();
    if (!commandTag)
        return '';
    let signature;
    if (node.kind === 1024) {
        if (!node.type.declaration)
            return '';
        signature = node.type.declaration.signatures[0];
    }
    else if (node.kind === 2048) {
        signature = node.signatures[0];
    }
    else {
        return '';
    }
    const params = [...signature.parameters];
    let result = commandTag + punct('(');
    params.shift();
    if (params.length > 0) {
        result += punct('[');
        result += span('"' + node.name + '"', 'string-literal');
        result += punct(', ');
        result += params.map((x) => render(x)).join(punct(', '));
        result += punct(']');
    }
    else {
        result += span('"' + node.name + '"', 'string-literal');
    }
    result += punct(')');
    if (signature.type) {
        result += punct(': ');
        result += render(signature.type);
    }
    if (params.length > 0 || signature.type) {
        result += '\n<dl>\n';
        if (params.length > 0) {
            result +=
                '\n<dt>\n' +
                    params
                        .map((param) => {
                        let r = '<strong><var>' + param.name + '</var></strong>';
                        const typeDef = render(param.type, 'block');
                        if (typeDef) {
                            r += punct(': ') + typeDef;
                        }
                        r += '\n</dt><dd>\n';
                        r += renderComment(param, 'block');
                        return r;
                    })
                        .join('\n</dd><dt>\n');
            result += '\n</dd>\n';
        }
        if (signature.type && hasTag(node, 'returns')) {
            result += '\n<dt>\n';
            result += '<strong>â†’ </strong>' + render(signature.type);
            result += '\n</dt><dd>\n';
            if (hasTag(node, 'returns')) {
                result += renderNotices(node, getTag(node, 'returns'));
            }
            result += '\n</dd>\n';
        }
        result += '\n</dl>\n';
    }
    result = div(result, 'code');
    return renderCard(node, span('command', 'modifier-tag') +
        '<strong>' +
        '&#8203;' +
        node.name +
        '</strong>', result + renderComment(node, 'block'));
}
function renderPropertyCard(node) {
    if (shouldIgnore(node))
        return '';
    const result = renderCommandCard(node);
    if (result)
        return result;
    const parent = getParent(node);
    let displayName = '';
    let shortName = '';
    if (parent && (parent.kind & (1 | 2 | 4 | 128 | 256)) !== 0) {
        shortName = `<strong>${node.name}</strong>`;
        displayName = parent.name + '.' + shortName;
    }
    return renderCard(node, displayName, render(node.type, 'block') + renderComment(node, 'block'));
}
function renderEnumCard(node) {
    if (shouldIgnore(node))
        return '';
    let comment = renderComment(node, 'block');
    let body = '';
    if (node.children) {
        if (comment)
            comment += '\n<hr>';
        body += '\n<dl>';
        body += node.children
            .map((enumMember) => {
            return render(enumMember, 'block');
        })
            .join('');
        body += '</dl>';
    }
    return renderCard(node, '', comment + body);
}
function renderTypeAliasCard(node) {
    if (shouldIgnore(node))
        return '';
    let result = renderComment(node, 'block');
    const typeDef = render(node, 'block');
    if (typeDef) {
        if (result) {
            result += '\n<hr>\n';
        }
        result += div(typeDef, 'code');
    }
    return renderCard(node, '', result);
}
function renderGroup(node, group) {
    const topics = getCategories(node, group.kind);
    if (topics.length === 0)
        return '';
    let header = '';
    if (group.kind !== 512 &&
        group.kind !== 262144 &&
        group.kind !== 4) {
        if ((group.kind === 1024 || group.kind === 2048) &&
            hasTag(node, 'command')) {
            header += renderIndex(node, '', topics);
        }
        else if ((group.kind & (2 | 4 | 128 | 256)) === 0 &&
            group.children.length > 1) {
            const displayTitle = {
                1: 'Modules',
                2: 'Namespaces',
                4: 'Enums',
                32: 'Variables',
                64: 'Functions',
                128: 'Classes',
                245: 'Interfaces',
                4194304: 'Types',
            }[group.kind];
            header += renderIndex(node, displayTitle, topics);
        }
    }
    const body = topics
        .map((topic) => {
        let r = '';
        if (topic.title) {
            r = heading(3, '', topic.title, null, {
                className: 'category-title',
            });
        }
        r += filterInherited(topic.children)
            .filter((x) => x.id !== node.extendedTypes?.[0].id ?? -1)
            .map((x) => render(x, 'section'))
            .join('');
        return r;
    })
        .join('');
    if (!body)
        return '';
    return section(header + body);
}
function renderGroups(node) {
    if (!node.groups)
        return '';
    const groups = sortGroups(node.groups);
    return (renderComment(node, 'section') +
        groups
            .map((x) => renderGroup(node, x))
            .filter((x) => !!x)
            .join('\n\n'));
}
function render(node, style = 'inline') {
    if (typeof node === 'undefined')
        return '';
    if (typeof node === 'number')
        node = getReflectionByID(node);
    if (typeof node === 'string')
        node = getReflectionByName(node);
    if (style === 'section' && node.groups) {
        if (node.kind === 128 || node.kind === 256) {
            return renderClassSection(node);
        }
        else if (node.kind === 4) {
            return renderEnumCard(node);
        }
        else if (node.kind === 1) {
            const permalink = makePermalink(node);
            const result = heading(2, '', getQualifiedName(node), permalink) +
                renderGroups(node);
            return section(result, { permalink });
        }
        return renderGroups(node);
    }
    const parent = getParent(node);
    if (typeof node.kind === 'undefined') {
        if (node.type === 'abstract') {
            console.error('Unexpected node type ', node.type);
        }
        if (node.type === 'array') {
            return render(node.elementType, 'inline') + punct('[]');
        }
        if (node.type === 'conditionals') {
            console.error('Unexpected node type ', node.type);
        }
        if (node.type === 'index') {
            console.error('Unexpected node type ', node.type);
        }
        if (node.type === 'indexedAccess') {
            return (render(node.objectType) +
                punct('[') +
                render(node.indexType) +
                punct(']'));
        }
        if (node.type === 'inferred') {
            console.error('Unexpected node type ', node.type);
        }
        if (node.type === 'intersection') {
            if (style === 'block') {
                return ('<ul class="type-block"><li>' +
                    node.types
                        .map((x) => render(x, 'block'))
                        .filter((x) => !!x)
                        .join(punct(' &amp; ') + '</li>\n<li>') +
                    '</li></ul>');
            }
            return node.types
                .map((x) => render(x))
                .filter((x) => !!x)
                .join(punct(' &amp; '));
        }
        if (node.type === 'intrinsic') {
            return keyword(node.name);
        }
        if (node.type === 'predicate') {
            console.error('Unexpected node type ', node.type);
        }
        if (node.type === 'query') {
            return keyword('typeof ') + render(node.queryType);
        }
        if (node.type === 'reference') {
            let typeArguments = '';
            if (node.typeArguments) {
                typeArguments =
                    punct('&lt;') +
                        node.typeArguments.map((x) => render(x)).join(punct(', ')) +
                        punct('&gt;');
            }
            let candidate;
            if (typeof node.id !== 'undefined') {
                candidate = getReflectionByID(node.id);
            }
            if (!candidate) {
                candidate = getReflectionByName(node.name, parent, 4 | 128 | 256 | 4194304);
            }
            if (candidate) {
                return (renderPermalink(makePermalink(candidate), candidate.kind === 16
                    ?
                        parent.name + '.' + node.name
                    : node.name) + typeArguments);
            }
            candidate = getReflectionByName(node.name, undefined, 4 | 128 | 256 | 4194304);
            if (candidate) {
                return (renderPermalink(makePermalink(candidate), node.name) +
                    typeArguments);
            }
            if (candidate) {
                return node.name + typeArguments;
            }
            if ([
                'Object',
                'Function',
                'Boolean',
                'Symbol',
                'String',
                'RegExp',
                'Object',
                'Number',
                'BigInt',
                'Math',
                'Date',
                'Infinity',
                'NaN',
                'globalThis',
                'Error',
                'AggregateError',
                'InternalError',
                'RangeError',
                'ReferenceError',
                'SyntaxError',
                'TypeError',
                'URIError',
                'Array',
                'Int8Array',
                'Uint8Array',
                'Uint8Array',
                'Uint8ClampedArray',
                'Int16Array',
                'Uint16Array',
                'Int32Array',
                'Uint32Array',
                'Float32Array',
                'Float64Array',
                'BigInt64Array',
                'BigUint64Array',
                'Map',
                'Set',
                'WeakMap',
                'WeakSet',
                'ArrayBuffer',
                'SharedArrayBuffer',
                'Atomics',
                'DataView',
                'JSON',
                'Promise',
                'Generator',
                'GeneratorFunction',
                'AsyncFunction',
                'Iterator',
                'AsyncIterator',
                'Reflect',
                'Proxy',
                'Intl',
                'WebAssembly',
            ].includes(node.name)) {
                return ('<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/' +
                    node.name +
                    '" class="externallink">' +
                    node.name +
                    '<svg><use xlink:href="#external-link"></use></svg>' +
                    '</a>' +
                    typeArguments);
            }
            const typescriptUtilityType = {
                Partial: 'partialtype',
                Readonly: 'readonlytype',
                Record: 'recordtype',
                Pick: 'picktype',
                Omit: 'omitype',
                Exclude: 'excludetype',
                Extract: 'extracttype',
                NonNullable: 'nonnullabletype',
                Parameters: 'parameterestype',
                ConstructorParameters: 'constructorparameterstype',
                ReturnType: 'returntype',
                InstanceType: 'instancetype',
                Required: 'requiredtype',
                ThisParameterType: 'thisparametertype',
                OmitThisParameter: 'omitthisparametertype',
                ThisType: 'thistypetype',
            }[node.name];
            if (typescriptUtilityType) {
                return ('<a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#' +
                    typescriptUtilityType +
                    '" class="externallink">' +
                    node.name +
                    '<svg><use xlink:href="#external-link"></use></svg>' +
                    '</a>' +
                    typeArguments);
            }
            return ('<a href="https://developer.mozilla.org/Web/API/' +
                node.name +
                '" class="externallink">' +
                node.name +
                '<svg><use xlink:href="#external-link"></use></svg>' +
                '</a>' +
                typeArguments);
        }
        if (node.type === 'reflection') {
            return render(node.declaration, style);
        }
        if (node.type === 'stringLiteral') {
            return span('"' + node.value + '"', 'string-literal');
        }
        if (node.type === 'tuple') {
            return (punct('[') +
                node.elements
                    .map((x) => render(x))
                    .filter((x) => !!x)
                    .join(punct(', ')) +
                punct(']'));
        }
        if (node.type === 'typeOperator') {
            return keyword(node.operator + ' ') + render(node.target);
        }
        if (node.type === 'typeParameter') {
            let result = renderPermalink(makePermalink(node));
            if (node.constraint) {
                result += keyword(' extends ');
                result += render(node.constraint);
            }
            return result;
        }
        if (node.type === 'union') {
            if (style === 'block' && !everyStringLiteral(node.types)) {
                return ('<ul class="type-block"><li>' +
                    punct('| ') +
                    node.types
                        .map((x) => render(x))
                        .join('</li>\n<li>' + punct('| ')) +
                    '</li></ul>');
            }
            return node.types.map((x) => render(x)).join(punct(' | '));
        }
        if (node.type === 'unknown') {
            return '';
        }
        if (node.type === 'void') {
            return keyword('void');
        }
    }
    let result = '';
    switch (node.kind) {
        case 0:
        case 1:
        case 2:
        case 4:
            console.assert('Unexpected node kind ', Number(node.kind).toString());
            break;
        case 16:
            result = `<dt id="${encodeURIComponent(makePermalink(node).anchor)}">`;
            result += '<strong>' + node.name + '</strong>';
            if (typeof node.defaultValue === 'string') {
                result += punct(' = ') + node.defaultValue;
            }
            result += '</dt><dd>';
            result += renderFlags(node);
            result += renderComment(node, style);
            result += '</dd>';
            break;
        case 32:
            if (style === 'card' || style === 'section') {
                result = renderCard(node, '', div(render(node, 'block')) + renderComment(node, 'block'));
            }
            else {
                result += '<strong>' + node.name + '</strong>';
                if (hasFlag(node, 'isOptional')) {
                    result += span('?', 'modifier');
                }
                if (node.type?.type === 'unknown') {
                    result += punct(' = ');
                    result += node.type.name || '';
                }
                if (node.type?.type !== 'unknown') {
                    result += punct(': ');
                    result += render(node.type);
                }
            }
            break;
        case 64:
            if (style === 'card' || style === 'section') {
                result = renderMethodCard(node);
            }
            else {
                console.warn('Unexpected style, kind ', node.kind);
            }
            break;
        case 128:
            if (style === 'card' || style === 'section') {
                result = renderClassCard(node);
            }
            else {
                result = node.name;
            }
            break;
        case 256:
            if (style === 'card' || style === 'section') {
                result = renderClassCard(node);
            }
            else {
                result = node.name;
            }
            break;
        case 512:
            if (style === 'card' || style === 'section') {
                result = renderMethodCard(node);
            }
            else {
                result = 'constructor' + render(node.signatures[0], style);
            }
            break;
        case 1024:
            if (style === 'card' || style === 'section') {
                result = renderPropertyCard(node);
            }
            else {
                if (node.name[0] !== '#') {
                    result =
                        (parent ? parent.name + '.' : '') +
                            node.name +
                            punct(': ') +
                            render(node.type, style);
                }
            }
            break;
        case 2048:
            if (style === 'card' || style === 'section') {
                result = renderMethodCard(node);
            }
            else {
                result = renderComment(node, 'block');
            }
            break;
        case 4096:
        case 16384:
            if (style === 'inline') {
                result = punct('(');
                if (node.parameters) {
                    result += node.parameters
                        .map((x) => render(x))
                        .join(punct(', '));
                }
                result += punct(')');
                result += punct(': ') + render(node.type);
            }
            else if (style === 'block') {
                if (node.parameters || node.type) {
                    result += '\n<dl>\n';
                    if (node.parameters) {
                        result +=
                            '\n<dt>\n' +
                                node.parameters
                                    .map((param) => {
                                    let r = '<strong><var>' +
                                        param.name +
                                        '</var></strong>';
                                    const typeDef = render(param.type, 'block');
                                    if (typeDef) {
                                        r += punct(': ') + typeDef;
                                    }
                                    r += '\n</dt><dd>\n';
                                    r += renderComment(param, style);
                                    return r;
                                })
                                    .join('\n</dd><dt>\n');
                        result += '\n</dd>\n';
                    }
                    if (node.type &&
                        (node.comment?.returns ||
                            !isVoid(node.type))) {
                        result += '\n<dt>\n';
                        result +=
                            '<strong>â†’ </strong>' +
                                render(node.type);
                        result += '\n</dt><dd>\n';
                        if (node.comment?.returns) {
                            result += renderNotices(node, node.comment.returns);
                        }
                        result += '\n</dd>\n';
                    }
                    result += '\n</dl>\n';
                }
            }
            else {
                console.error('Call signature style not supported');
            }
            break;
        case 8192:
            result +=
                punct('[') +
                    node.parameters.map((x) => render(x)).join(punct(', ')) +
                    punct(']');
            result += punct(': ') + render(node.type);
            break;
        case 32768:
            if (hasFlag(node, 'isRest')) {
                result += span('...', 'modifier');
            }
            result += `<var>${node.name}</var>`;
            if (hasFlag(node, 'isOptional')) {
                result += span('?', 'modifier');
            }
            result += punct(': ') + render(node.type);
            break;
        case 65536:
            if (node.signatures) {
                result += node.signatures
                    .map((x) => render(x))
                    .join(punct('; '));
            }
            else if (node.children || node.indexSignature) {
                if (style === 'block' || style === 'block-inherit') {
                    result += '<div><dl>';
                    if (node.children) {
                        result +=
                            '<dt>' +
                                node.children
                                    .map((x) => {
                                    let dt = render(x) + punct(';');
                                    if (hasTag(x, 'deprecated')) {
                                        dt = span(dt, 'deprecated');
                                    }
                                    const dd = renderFlags(x) +
                                        renderComment(x, style);
                                    return dt + '</dt><dd>' + dd;
                                })
                                    .join('</dd><dt>');
                        result += '</dd>';
                    }
                    if (node.indexSignature) {
                        result += '<dt>';
                        result += node.indexSignature
                            .map((x) => render(x))
                            .join(punct(';') + '</dt><dd>');
                        result += '</dd>';
                    }
                    result += '</dl>' + '</div>';
                }
                else if (style === 'inline') {
                    result += punct('{');
                    if (node.children) {
                        result += node.children
                            .map((x) => render(x))
                            .join(punct('; '));
                    }
                    if (node.indexSignature) {
                        result += node.indexSignature
                            .map((x) => render(x))
                            .join(punct('; '));
                    }
                    result += punct('}');
                }
                else {
                    console.error('Unexpected style for Type Literal');
                }
            }
            break;
        case 131072:
            result += node.name;
            if (node.type) {
                result += keyword(' extends ');
                result += render(node.type);
            }
            break;
        case 524288:
        case 1048576:
            console.warn(`Unexpected kind = ${node.kind} for ${getQualifiedName(node).replace(/<[^>]*>/g, ' ')}`);
            break;
        case 262144:
            if (style === 'card' || style === 'section') {
                result = renderAccessorCard(node);
            }
            else {
                console.warn('Unexpected style, kind ', node.kind);
            }
            break;
        case 2097152:
            console.warn('Unexpected style, kind ', node.kind);
            break;
        case 4194304:
            if (style === 'card' || style === 'section') {
                result = renderTypeAliasCard(node);
            }
            else {
                const def = render(node.type, style);
                result = '';
                if (node.typeParameter) {
                    result += punct('&lt;');
                    result += node.typeParameter
                        .map((typeParam) => render(typeParam))
                        .join(punct(', '));
                    result += punct('&gt;');
                    if (def) {
                        result += punct(' = ');
                    }
                }
                result += def;
            }
            break;
        case 8388608:
            console.warn('Unexpected style, kind ', node.kind);
            break;
        case 16777216:
            break;
        default:
            console.warn(`Unexpected kind = ${node.kind} for ${getQualifiedName(node).replace(/<[^>]*>/g, ' ')}`);
    }
    return result;
}
function getReflectionsFromFile(src, options) {
    let result = {};
    const app = new TypeDoc.Application();
    app.options.addReader(new TypeDoc.TSConfigReader());
    app.options.addReader(new TypeDoc.TypeDocReader());
    app.bootstrap({
        logger: (message, _level, _newline) => console.log(message),
        mode: 'modules',
        target: 'es2019',
        module: 'ESNext',
        experimentalDecorators: true,
        moduleResolution: 'node',
        noEmit: 'true',
        stripInternal: false,
        includeDeclarations: true,
        excludeExternals: true,
    });
    src = app.expandInputFiles(src.map((x) => {
        const f = path.resolve(path.normalize(x));
        if (!fs.existsSync(f)) {
            console.warn('File not found "' + f + '"');
        }
        return f;
    }));
    const convertResult = app.converter.convert(src);
    if (convertResult.errors?.length) {
        app.logger.diagnostics(convertResult.errors);
        if (options.ignoreErrors) {
            app.logger.resetErrors();
        }
        else {
            return undefined;
        }
    }
    if (convertResult.project) {
        result = app.serializer.projectToObject(convertResult.project);
    }
    return result;
}
function applyTemplate(src, substitutions) {
    if (typeof src === 'string') {
        Object.keys(substitutions).forEach((key) => {
            if (typeof substitutions[key] === 'string') {
                src = src.replace(new RegExp('{{' + key + '}}', 'g'), substitutions[key]);
            }
        });
        return src;
    }
    if (typeof src === 'function') {
        return src(substitutions);
    }
    return '';
}
let gNodes;
let gOptions;
function grok(src, options) {
    try {
        gOptions = options;
        gNodes = getReflectionsFromFile(src, options);
        const sdkName = options.sdkName ?? '';
        const packageName = options.sdkName ?? gNodes.name ?? '';
        let content;
        if (options.modules) {
            const modules = options.modules
                .map((x) => getReflectionByName(x, gNodes, 1))
                .filter((x) => !!x);
            if (modules.length === 0) {
                console.warn('Modules ' +
                    options.modules.join(', ') +
                    ' not found in "' +
                    src +
                    '"');
            }
            else if (modules.length !== options.modules.length) {
                const moduleNames = modules.map((x) => getName(x));
                console.warn('Module ' +
                    options.modules
                        .filter((x) => !moduleNames.includes(x))
                        .join(', ') +
                    ' in "' +
                    src +
                    '"');
            }
            content = renderIndex(gNodes, 'Modules', [
                {
                    title: '',
                    children: modules,
                },
            ]);
            content += modules.map((x) => render(x, 'section')).join('');
            content = section(content);
        }
        if (!content)
            content = render(gNodes, 'section');
        if (content) {
            const document = applyTemplate(options.documentTemplate, {
                packageName: escapeYAMLString(packageName),
                sdkName: escapeYAMLString(trimNewline(sdkName)),
                cssVariables: options.cssVariables,
                content,
            });
            return { [options?.outFile ?? 'index.html']: document };
        }
    }
    catch (err) {
        console.error(err);
    }
    return {};
}

const chalk = require('chalk');
const ciInfo = require('ci-info');
const tcOrange = '#ffcc00';
const tcRed = '#fa2040';
const tcBlue = '#6ab3ff';
const tcPurple = '#d1d7ff';
let gUseColor = (process.stdout.isTTY ?? false) && !ciInfo.isCI;
const terminal = {
    useColor: (flag) => {
        gUseColor = flag;
    },
    autoFormat: (m) => {
        return m
            .replace(/("(.*)")/g, (x) => {
            return terminal.string(x.slice(1, -1));
        })
            .replace(/(`(.*)`)/g, (x) => {
            return terminal.keyword(x);
        });
    },
    success: (m = '') => {
        chalk.green('âœ”ï¸Ž   ' + m);
        return gUseColor ? chalk.bold.green('âœ”ï¸Ž   ' + m) : 'âœ”ï¸Ž   ' + m;
    },
    error: (m = '') => {
        return gUseColor
            ? chalk.hex(tcRed)(chalk.bold('âœ˜   ' + m))
            : 'âœ˜   ' + m;
    },
    warning: (m = '') => {
        return gUseColor
            ? chalk.hex(tcOrange)(chalk.bold('âš ï¸   ' + m))
            : 'âš    ' + m;
    },
    path: (m = '') => {
        return gUseColor ? chalk.hex(tcBlue).italic(m) : m;
    },
    keyword: (m = '') => {
        return gUseColor ? chalk.hex(tcOrange)(m) : m;
    },
    string: (m = '') => {
        return gUseColor
            ? chalk.hex(tcOrange)('"' + chalk.italic(m) + '"')
            : '"' + m + '"';
    },
    dim: (m = '') => {
        return gUseColor ? chalk.hex('#999')(m) : m;
    },
    time: (t = new Date()) => {
        return gUseColor
            ? chalk.hex(tcPurple)(`[${t.toLocaleTimeString()}]`)
            : '[' + t + ']';
    },
    link: (m) => {
        return gUseColor
            ? '\nâ–·   ' +
                chalk.hex(tcPurple)('https://github.com/arnog/chromatic/docs/errors/' +
                    m +
                    '.md')
            : '\nâ–·   https://github.com/arnog/chromatic/docs/errors/' +
                m +
                '.md';
    },
};

const pkg = require('../package.json');
require('please-upgrade-node')(pkg);
const updateNotifier = require('update-notifier');
updateNotifier({ pkg, shouldNotifyInNpmScript: true }).notify();
const { cosmiconfigSync } = require('cosmiconfig');
const configParser = cosmiconfigSync('grok');
const path$1 = require('path');
const fs$1 = require('fs-extra');
function mergeObject(object, source) {
    if (object === source)
        return;
    if (!source)
        return;
    Object.keys(source).forEach((key) => {
        if (Array.isArray(source[key])) {
            if (!object[key])
                object[key] = [];
            object[key] = [...object[key], ...source[key]];
        }
        else if (typeof source[key] === 'object') {
            if (!object[key])
                object[key] = {};
            mergeObject(object[key], source[key]);
        }
        else if (typeof source[key] !== 'undefined') {
            object[key] = source[key];
        }
    });
}
function outputResult(outDir, result) {
    fs$1.mkdir(outDir, { recursive: true });
    Object.keys(result).forEach((x) => {
        fs$1.writeFileSync(path$1.resolve(path$1.normalize(path$1.join(outDir, x))), result[x]);
    });
}
function build(argv) {
    try {
        const options = {
            sdkName: 'module',
            verbose: false,
            tutorialPath: '',
            cssVariables: {
                monospace: 'IBM Plex Mono, monospace',
                'primary-color': '#0066ce',
            },
            documentTemplate: (options) => `<!doctype html>
<html class="no-js" lang="">

<head>
    <meta charset="utf-8">
    <title>${options.packageName} -- ${options.packageName}</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="manifest" href="site.webmanifest">
    <link rel="apple-touch-icon" href="icon.png">
    <style>
    body {${Object.keys(options.cssVariables)
                .map((x) => '--' + x + ':' + options.cssVariables[x])
                .join(';')}}
    .main {
        margin: auto;
        max-width: 820px;
    }
    .sr-only {
        position: absolute !important;
        clip: rect(1px, 1px, 1px, 1px);
        height: 1px !important;
        width: 1px !important;
        border: 0 !important;
        overflow: hidden; 
    }
    svg {
        width: 1em;
        height: 1em;
    }

    .stack {
        display: flex;
        flex-flow: column;
    }

    /* For the sub-heading */
    h2 em {
        display: block;
        font-size: 0.7rem;
        line-height: .8;
        font-style: normal;
    }
    
    /* For the "main" symbol in the heading */
    h2 strong {
        font-weight: 700;
    }

    h2 span.subhead, h3 span.subhead {
        display: block;
        font-size: .8rem;
        line-height: .8;
        font-weight: 400;
        font-style: normal;
    }
    
    code, .code {
        font-family: monospace;
        display: inline;
        overflow-wrap: break-word;
    }

    .card {
        display: block;
    
        margin-top: 30px;
        margin-bottom: 40px;
        overflow: hidden;
        padding: 20px 17px;
        border-radius: 4px;
        border: 1px solid #fafafa;
        background-color: #fefefe;
        color: #000;
        max-width: 820px;
        box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba(0, 0, 0, 0.23);
    }

    .card h3 {
        display: flex;
        justify-content: space-between;
        width: calc(100% + 40px);
        margin-top: -25px;
        margin-bottom: 10px;
        margin-left: -10px;
        margin-right: -20px;
        padding: 20px;
        padding-bottom: 10px;
    
        font-family: monospace;
        font-size: 1.2rem;
        line-height: 1.5;
        font-weight: 400;
    
        white-space: nowrap;
    
        border: none;
        border-bottom: 1px solid #e7e7e7;
        box-sizing: border-box;
    }

    .index ul,
    ul.index {
        column-width: 28ex; // Approx. maximum length of a symbol (in char)
        column-gap: 20px;
        padding: 0;
        list-style: none;
        line-height: 1.333;
    }
    
    .index li {
        display: flex;
        font-family: var(--monospace);
        margin: 0;
        box-sizing: content-box;
        break-inside: avoid-column;
    }
    
    .index li a,
    .index li a:visited {
        text-decoration: none;
    }
    
    .index li a:hover,
    .index li a:active {
        color: var(--primary-color);
    }
    /* Categories */
    .index h3 {
        background: transparent;
        border: none;
        font-weight: 700;
        margin: 0;
        padding: 0;
    }
    
    /* Anchor icon */
    .permalink { 
        float: right;
    }
        
    /* The name of a referenced type, e.g. */
    /* Bar in type Foo = Bar */
    .reference, .typeParameter {
        font-weight: 700;
    }
    
    /* For a string, in quotes */
    .string-literal {
        color: #666;
    }
    
    /* Punctuation signs, "=", "|", ":".  */
    /* For example "type foo = number" */
    .punctuation {
        color: rgb(103, 103, 236); /* indigo-400 */
        font-weight: 700;
    }
    
    /* For "string", "number", "void", "typeof", etc... */
    .keyword {
        color: rgb(146, 86, 217); /* purple-400 */
    }
    
    /* The "?" symbol to indicate optional arguments */
    /* The '...' string to indicate 'rest' arguments */
    .modifier {
        color: rgb(216, 55, 144); /* $magenta-400; */
        font-weight: 700;
    }

    .modifier-tag, .tag-name {
        display: inline-block;
        white-space: nowrap;
        font-size: 13px;
        line-height: 18px;
        font-weight: 400;
        font-variant: normal;
        font-style: normal;
        color: var(--primary-color);
    
        height: 22px;
    
        margin-left: 0;
        margin-right: 16px;
    
        padding-left: 10px;
        padding-right: 10px;
        padding-top: 1px;
        padding-bottom: 1px;
    
        box-sizing: border-box;
        -webkit-font-smoothing: antialiased;
    
        border: 1px solid var(--primary-color);
        border-radius: 3px;
    
        background: transparent;
    
        min-width: 90px;
        text-align: center;
    
        vertical-align: middle;
    }
    </style>

</head>

<body>
    <svg xmlns="http://www.w3.org/2000/svg" style="display:none">
    <defs>
        <symbol id='link' viewBox="0 0 512 512" >
            <path fill="currentColor" d="M326.612 185.391c59.747 59.809 58.927 155.698.36 214.59-.11.12-.24.25-.36.37l-67.2 67.2c-59.27 59.27-155.699 59.262-214.96 0-59.27-59.26-59.27-155.7 0-214.96l37.106-37.106c9.84-9.84 26.786-3.3 27.294 10.606.648 17.722 3.826 35.527 9.69 52.721 1.986 5.822.567 12.262-3.783 16.612l-13.087 13.087c-28.026 28.026-28.905 73.66-1.155 101.96 28.024 28.579 74.086 28.749 102.325.51l67.2-67.19c28.191-28.191 28.073-73.757 0-101.83-3.701-3.694-7.429-6.564-10.341-8.569a16.037 16.037 0 0 1-6.947-12.606c-.396-10.567 3.348-21.456 11.698-29.806l21.054-21.055c5.521-5.521 14.182-6.199 20.584-1.731a152.482 152.482 0 0 1 20.522 17.197zM467.547 44.449c-59.261-59.262-155.69-59.27-214.96 0l-67.2 67.2c-.12.12-.25.25-.36.37-58.566 58.892-59.387 154.781.36 214.59a152.454 152.454 0 0 0 20.521 17.196c6.402 4.468 15.064 3.789 20.584-1.731l21.054-21.055c8.35-8.35 12.094-19.239 11.698-29.806a16.037 16.037 0 0 0-6.947-12.606c-2.912-2.005-6.64-4.875-10.341-8.569-28.073-28.073-28.191-73.639 0-101.83l67.2-67.19c28.239-28.239 74.3-28.069 102.325.51 27.75 28.3 26.872 73.934-1.155 101.96l-13.087 13.087c-4.35 4.35-5.769 10.79-3.783 16.612 5.864 17.194 9.042 34.999 9.69 52.721.509 13.906 17.454 20.446 27.294 10.606l37.106-37.106c59.271-59.259 59.271-155.699.001-214.959z">
            </path>
        </symbol>
        <symbol id='external-link' viewBox="0 0 512 512">
            <path fill="currentColor" d="M432,320H400a16,16,0,0,0-16,16V448H64V128H208a16,16,0,0,0,16-16V80a16,16,0,0,0-16-16H48A48,48,0,0,0,0,112V464a48,48,0,0,0,48,48H400a48,48,0,0,0,48-48V336A16,16,0,0,0,432,320ZM474.67,0H316a28,28,0,0,0-28,28V46.71A28,28,0,0,0,316.79,73.9L384,72,135.06,319.09l-.06.06a24,24,0,0,0,0,33.94l23.94,23.85.06.06a24,24,0,0,0,33.91-.09L440,128l-1.88,67.22V196a28,28,0,0,0,28,28H484a28,28,0,0,0,28-28V37.33h0A37.33,37.33,0,0,0,474.67,0Z">
            </path>
        </symbol>
    </defs>
    </svg>
    <div class='main'>
    ${options.content}
    <div>Documentation built with <a href="https://github.com/ui-js/grok"><code>grok</code></a></div>
    </div>
</body>    
</html>
`,
        };
        let configResult = configParser.search();
        if (!!configResult?.config) {
            mergeObject(options, configResult.config);
        }
        if (argv['config']) {
            configResult = configParser.load(argv['config']);
            if (!!configResult?.config) {
                mergeObject(options, configResult.config);
            }
        }
        mergeObject(options, argv);
        if (!argv['paths'] || argv['paths'].length < 1) {
            console.error(terminal.error() +
                `Expected at least one path to a directory or TypeScript declaration file.\n` +
                `    Use ${terminal.keyword(argv.$0 + ' help')} for available options.\n`);
            process.exit(1);
        }
        outputResult(options['outDir'] || '.', grok(argv['paths'], options));
    }
    catch (err) {
        console.error(err);
    }
}
function buildOptions(yargs) {
    yargs
        .positional('<path>', {
        describe: 'Path to a TypeScript declaration file or directory',
        type: 'path',
    })
        .normalize('path')
        .option('sdkName', {
        describe: 'Name of the API/Library/Module being documented',
        type: 'string',
    })
        .option('outFile', {
        describe: 'Save output to file (in outDir)',
        type: 'path',
    })
        .normalize('outFile')
        .option('outDir', {
        alias: 'o',
        describe: 'Save output to path',
        type: 'path',
    })
        .normalize('outDir')
        .option('config', {
        describe: 'Load config file from path',
        type: 'path',
    })
        .normalize('config')
        .option('verbose', {
        describe: 'Display additional information during processing',
        type: 'boolean',
    })
        .option('no-color', {
        describe: 'Suppress color output in terminal',
        type: 'boolean',
    })
        .option('ignore-errors', {
        alias: 'i',
        describe: 'Attempt to continue when an error is encountered',
        type: 'boolean',
    });
}
require('yargs')
    .usage('Usage: $0 file(s) [options]')
    .example('$0 ./src/index.d.ts -o ./build/index.html', 'Generate a HTML documentation page from a TypeScript declaration file')
    .command(['* <paths..>', 'build <paths..>'], 'Build documentation', buildOptions, build)
    .command('help', 'Show help', () => {
    return;
}, (yargs) => yargs.help())
    .help('h')
    .alias('h', 'help')
    .epilog('For more information, see https://github.com/ui-js/grok')
    .strict(true)
    .parse();
//# sourceMappingURL=grok-cli.map
